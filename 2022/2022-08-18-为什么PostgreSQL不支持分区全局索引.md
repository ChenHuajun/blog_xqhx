## 问题
PostgreSQL从10的时候开始支持声明式分区，到现在已经有5年了，但是PG还没有支持分区表的全局索引。
这是为什么？社区邮件列表中有一个讨论可以解释这个问题。

- [Proposal: Global Index](https://www.postgresql.org/message-id/flat/8cd6b125-2f3f-01bc-f41b-5c8343685a21%40amazon.com#ead9539bae43281bf0ae609204972649)

相关内容概况如下

## 分区表的作用
首先考虑我们为什么进行分区，主要有下面的好处
1. 改善查询性能
    - 对分区对象的查询可以仅搜索自己关心的分区，提高检索效率。
    - 降低Btree索引的高度，提升查询和更新Btree的性能。
2. 方便维护
    - 可以删除或清空单个分区，特别是按时间分区时，归档历史数据特别方便。
    - vacuum，统计信息收集可以针对每个分区分别执行，甚至并行执行
3. 增强可用性
    - 如果分区表的某个分区出现故障，表在其他分区的数据仍然可用。
4. 均衡I/O
    - 可以把不同的分区映射到不同的磁盘以平衡I/O，改善整个系统性能。
最明显的好处是上面的1和2 。

但是分区同时也带来了一些问题
1. 无法定义不带分区字段的唯一约束
2. 对不带分区字段条件的查询，即使实际只有少量分区包含匹配的数据，也要扫描所有分区，性能较差。

## 全局索引的利于弊
对于上面的问题2，有人提出可以维护每个分区级别的全局稀疏索引，比如记录相关字段的最大值，最小值，用于分区减枝。
这就相当于分区粒度的全局 BRIN 索引。
这个方案依赖被索引字段和分区字段的相关性，仅适用于相关性好的场景。
比如：包含许多日期列的时间序列表（第一次更新行、最新行更新、发票日期、付款
日期、处理日期、发货日期， ETC）。分区字段是其中一个日期字段。

所以这种方法局限性很大，只能部分解决问题2，对问题1无能为力。

要很好的解决上面的问题，通用的办法是全局索引。参考Bruce Momjian的Blog，全局索引有3个使用场景
https://momjian.us/main/blogs/pgblog/2020.html#July_1_2020
1. 覆盖所有分区数据的索引，这将允许分区表作为外键的被参考表
2. 支持不包含分区键的唯一约束
3. 通过索引快速查找只存在于少量分区，并且不是分区键一部分的值

但是，引入全局索引也会带来非常大的负面影响
1. 全局索引的Btree高度比较大
2. 清空，删除分区或ATTACH带数据的分区时会带来全局索引维护的巨大开销
3. vacuum每个分区都要顺带清理全局分区索引，导致非常严重的写放到
   比如：如果有100个分区，每个分区的vacuum都会触发全局分区索引清理，导致全局分区索引清理执行了100倍。

上面的1和2抵消了很多分区带来的好处，而问题3几乎是灾难性的，成为PG实现全局分区索引的最大障碍。
主要因为这个原因，关于全局索引的讨论就没有然后了，解决这个问题也许要指望zheap。

除了zheap，也许可以通过某种机制缓解问题3的副作用，比如：延迟全局索引清理到全局索引中死元组堆积到一定比例。

## 参考
- [Proposal: Global Index](https://www.postgresql.org/message-id/flat/8cd6b125-2f3f-01bc-f41b-5c8343685a21%40amazon.com#ead9539bae43281bf0ae609204972649)
- [openGauss---创建和管理分区表](https://www.modb.pro/db/37665)
