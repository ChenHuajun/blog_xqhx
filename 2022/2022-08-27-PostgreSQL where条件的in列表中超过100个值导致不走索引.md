## 问题
最近遇到一个案例，where条件的in列表中的值超过100会导致不会走条件索引。
参考下面的例子

## 示例

### 建表

```
create table tb1(id int);
insert into tb1 select generate_series(1,1000000);
create index on tb1(id) where id > 0;
```

### in中带100个值的查询

```
postgres=# explain analyze select * from tb1 where id in(
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40
,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76
,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100);

            QUERY PLAN

------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------
 Index Only Scan using tb1_id_idx on tb1  (cost=0.42..440.25 rows=100 width=4) (actual time=0.074..0.318 rows=100 loops=1)
   Index Cond: (id = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44
,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94
,95,96,97,98,99,100}'::integer[]))
   Heap Fetches: 0
 Planning Time: 0.877 ms
 Execution Time: 0.342 ms
(5 rows)

```

### in中带101个值的查询
```
postgres=# explain analyze select * from tb1 where id in(
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40
,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76
,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101);

            QUERY PLAN

------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------
 Seq Scan on tb1  (cost=0.25..19425.25 rows=505000 width=4) (actual time=0.036..271.000 rows=101 loops=1)
   Filter: (id = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,
46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
96,97,98,99,100,101}'::integer[]))
   Rows Removed by Filter: 999899
 Planning Time: 0.225 ms
 Execution Time: 271.019 ms
(5 rows)

```

## 回避方法

在select中补充和条件索引一样的过滤条件。如下
```
postgres=# explain analyze select * from tb1 where id in(
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40
,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76
,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101) and id>0;

              QUERY PLAN

------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------
 Index Only Scan using tb1_id_idx on tb1  (cost=0.42..444.69 rows=101 width=4) (actual time=0.044..0.787 rows=101 loops=1)
   Index Cond: (id = ANY ('{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44
,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94
,95,96,97,98,99,100,101}'::integer[]))
   Heap Fetches: 0
 Planning Time: 0.558 ms
 Execution Time: 0.829 ms
(5 rows)

```


## 附录：相关代码
./src/backend/optimizer/util/predtest.c
```
/*
 * Proof attempts involving large arrays in ScalarArrayOpExpr nodes are
 * likely to require O(N^2) time, and more often than not fail anyway.
 * So we set an arbitrary limit on the number of array elements that
 * we will allow to be treated as an AND or OR clause.
 * XXX is it worth exposing this as a GUC knob?
 */
#define MAX_SAOP_ARRAY_SIZE     100
```
